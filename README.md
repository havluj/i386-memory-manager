# Disclaimer
This repository contains code that I wrote when studying Software Engineering at Czech Technical University in Prague.

The objective of these assignments was to write code that works, covers all edge cases, and is somewhat performant. Usually, there were additional rules we had to follow - like limits on the amount of memory our programs could use or that all code needed to be in a single file ğŸ¤·â€â™‚ï¸.

Please keep in mind that I wrote this code years ago and that it was a school assignment. This repository does not serve as the best example of my coding skills.

You can read the full assignment bellow (in Czech).

# Memory manager (i386)

Ãškolem je realizovat funkce a tÅ™Ã­dy implementujÃ­cÃ­ zjednoduÅ¡enou sprÃ¡vu virtuÃ¡lnÃ­ pamÄ›ti v OS.

CÃ­lem Ãºlohy je hlubÅ¡Ã­ pochopenÃ­ problematiky virtuÃ¡lnÃ­ pamÄ›ti a jejÃ­ sprÃ¡vy v OS. Pro ÃºÄely tÃ©to Ãºlohy vÅ¡ak byla celÃ¡ problematika drasticky zjednoduÅ¡ena. CelÃ© programovÃ¡nÃ­ probÃ­hÃ¡ na Ãºrovni C a C++ a nenÃ­ potÅ™eba pracovat s privilegovanÃ½mi instrukcemi CPU (tedy jednÃ¡ se o ÄistÄ› user-space program, nenÃ­ potÅ™eba znalost assembleru):

   * CPU bude implementovÃ¡no jako C++ tÅ™Ã­da CCPU, respektive jejÃ­ podtÅ™Ã­da. SimulovanÃ½ proces bude volat metody tÃ©to tÅ™Ã­dy, metody zprostÅ™edkujÃ­ ÄtenÃ­/zÃ¡pis do pamÄ›ti.
   * Proces bude simulovÃ¡n jako vlÃ¡kno. VlÃ¡kna bude vytvÃ¡Å™et VaÅ¡e implementace. Pro kaÅ¾dÃ½ vytvoÅ™enÃ½ "proces" zÃ¡roveÅˆ vytvoÅ™Ã­te instanci CCPU, instance bude pÅ™eklÃ¡dat adresy pro tento "proces".
   * Adresy - NÃ¡Å¡ user-space program samozÅ™ejmÄ› nemÅ¯Å¾e zmÄ›nit chovÃ¡nÃ­ adres na reÃ¡lnÃ©m CPU. V simulovanÃ½ch procesech proto budeme pracovat s adresami "uvnitÅ™" simulovanÃ©ho procesu, tyto adresy budeme pÅ™edÃ¡vat odpovÃ­dajÃ­cÃ­m metodÃ¡m tÅ™Ã­dy CCPU, kterÃ© adresy pÅ™eloÅ¾Ã­ na "opravdovÃ©" adresy a zprostÅ™edkujÃ­ zÃ¡pis/ÄtenÃ­. SimulovanÃ© adresy "uvnitÅ™" simulovanÃ©ho procesu budou tedy "virtuÃ¡lnÃ­" adresy, adresy v naÅ¡em programu budou vlastnÄ› "fyzickÃ©".
   * AdresnÃ­ prostor simulovanÃ©ho procesu V user-space simulaci nelze snadno zaÅ™Ã­dit simulaci celÃ©ho adresnÃ­ho prostoru simulovanÃ½ch "procesÅ¯". Budeme simulovat pouze ÄÃ¡st adresnÃ­ho prostoru - haldu simulovanÃ©ho procesu. Halda bude mÃ­t velmi primitivnÃ­ strukturu - simulovanÃ½ proces si pomocÃ­ funkcÃ­ bude moci alokovat poÅ¾adovanou velikost haldy (zadÃ¡ poÅ¾adovanÃ½ poÄet strÃ¡nek), simulovanÃ¡ halda bude adresovanÃ¡ simulovanÃ½mi virtuÃ¡lnÃ­mi adresami v rozsahu 0 aÅ¾ *poÄet_strÃ¡nek_haldy* * 4096 - 1.
   * PamÄ›Å¥ - PÅ™i inicializaci dostane funkce adresu poÄÃ¡tku a velikost bloku pamÄ›ti, se kterÃ½m hospodaÅ™Ã­. Tato pamÄ›Å¥ mÃ¡ velikost Å™Ã¡dovÄ› nÄ›kolik desÃ­tek MiB. To odpovÃ­dÃ¡ situaci, kterou mÃ¡ na startu reÃ¡lnÃ½ OS. Z tÃ©to pamÄ›ti budete uspokojovat poÅ¾adavky simulovanÃ½ch procesÅ¯ (do jejich adresnÃ­ho prostoru namapujete ÄÃ¡sti tÃ©to pamÄ›ti). KromÄ› tÃ©to pamÄ›ti mÃ¡ VaÅ¡e implementace k dispozici jeÅ¡tÄ› nÄ›kolik stovek KiB pamÄ›ti dostupnÃ© pÅ™es new/malloc a zÃ¡sobnÃ­k (zÃ¡sobnÃ­ky vlÃ¡ken). Takto dostupnÃ¡ pamÄ›Å¥ je malÃ¡, rozhodnÄ› nestaÄÃ­ pro poÅ¾adovanÃ© alokace. ReÃ¡lnÃ½ OS samozÅ™ejmÄ› moÅ¾nost volat new/malloc nemÃ¡, v tomto ohledu se jednÃ¡ o zjednoduÅ¡enÃ­.
   * SpuÅ¡tÄ›nÃ­ simulace - Simulace se spustÃ­ zavolÃ¡nÃ­m VaÅ¡Ã­ funkce *MemMgr*, poÅ¾adovanÃ© rozhranÃ­ je v pÅ™iloÅ¾enÃ©m souboru. Funkce dostane pomocÃ­ parametrÅ¯ spravovanÃ½ blok pamÄ›ti (ukazatel na jeho poÄÃ¡tek a jeho velikost v poÄtiu strÃ¡nek, kaÅ¾dÃ¡ strÃ¡nka je velikÃ¡ 4 KiB). DÃ¡le dostane ukazatel na funkci, tato funkce bude spuÅ¡tÄ›na jako prvnÃ­ "proces" - obdoba procesu init. Funkce zinicializuje VaÅ¡e internÃ­ struktury pro sprÃ¡vu pamÄ›ti, vytvoÅ™Ã­ instanci simulovanÃ©ho procesoru a spustÃ­ pÅ™edanou funkci. ZatÃ­m jeÅ¡tÄ› nenÃ­ potÅ™eba vytvÃ¡Å™et novÃ¡ vlÃ¡kna - init pobÄ›Å¾Ã­ v hlavnÃ­m vlÃ¡knu. Init samozÅ™ejmÄ› zaÄne vytvÃ¡Å™et dalÅ¡Ã­ simulovanÃ© procesy, pro vytvoÅ™enÃ­ je v rozhranÃ­ *CCPU* pÅ™Ã­sluÅ¡nÃ© volÃ¡nÃ­. Toto volÃ¡nÃ­ bude obslouÅ¾eno VaÅ¡Ã­ implementacÃ­ (vytvoÅ™enÃ­ dalÅ¡Ã­ instance *CCPU*, pÅ™idÄ›lenÃ­ pamÄ›ti, vytvoÅ™enÃ­ vlÃ¡kna, ...). Init samozÅ™ejmÄ› nÄ›kdy skonÄÃ­ (volÃ¡nÃ­ se vrÃ¡tÃ­ z pÅ™edanÃ© funkce), stejnÄ› tak skonÄÃ­ i ostatnÃ­ procesy. HlavnÃ­ vlÃ¡kno zpracovÃ¡vajÃ­cÃ­ proces init poÄkÃ¡ na dokonÄenÃ­ vÅ¡ech "procesÅ¯", uklidÃ­ VÃ¡mi alokovanÃ© prostÅ™edky a vrÃ¡tÃ­ se z *MemMgr*.
   * PoÄet simulovanÃ½ch procesÅ¯ - PoÄet vytvÃ¡Å™enÃ½ch procesÅ¯ je omezen na *PROCESS_MAX=64*. Tedy kromÄ› procesu init mÅ¯Å¾e najednou existovat nejvÃ½Å¡e 63 dalÅ¡Ã­ch "procesÅ¯". Procesy se ale mohou ukonÄovat a dalÅ¡Ã­ vznikat. Tedy celkem mÅ¯Å¾e vzniknout mnoho (neomezenÄ›) procesÅ¯, ale v jeden okamÅ¾ik jich pobÄ›Å¾Ã­ nejvÃ½Å¡e 64. Toto je potÅ™eba zohlednit pÅ™i ukonÄovÃ¡nÃ­ vlÃ¡ken, aby se systÃ©m nezahltil.
   * VytvÃ¡Å™enÃ­ novÃ½ch procesÅ¯ - NovÃ½ "proces" se vytvÃ¡Å™Ã­ volÃ¡nÃ­m metody *NewProcess*, tuto metodu budete implementovat v potomku tÅ™Ã­dy *CCPU*. Metoda dostÃ¡vÃ¡ parametrem ukazatel na funkci, kterÃ¡ bude spuÅ¡tÄ›na v novÃ©m "procesu" - vlÃ¡knu. DÃ¡le je parametrem netypovÃ½ ukazatel, kterÃ½ pÅ™edÃ¡te jako inicializaÄnÃ­ parametr (stejnÄ› jak to dÄ›lÃ¡ pthread_create. PoslednÃ­m parametrem je pÅ™Ã­znak, zda novÄ› vzniklÃ½ "proces" bude mÃ­t ve svÃ©m adresnÃ­m prostoru zcela "prÃ¡zdno" nebo zda zÃ­skÃ¡ kopii obsahu adresnÃ­ho prostoru svÃ©ho rodiÄe (chovÃ¡nÃ­ podobnÃ© funkci *fork*).

ZÃ¡kladem Å™eÅ¡enÃ­ je tÅ™Ã­da *CCPU*. Tato tÅ™Ã­da zjednoduÅ¡enÄ› simuluje chovÃ¡nÃ­ procesoru i386 pÅ™i pÅ™ekladu adres. ÄŒÃ¡st metod je implementovanÃ¡ (v testovacÃ­m prostÅ™edÃ­ a v pÅ™iloÅ¾enÃ©m zdrojovÃ©m kÃ³du). VaÅ¡Ã­m Ãºkolem bude od tÃ©to tÅ™Ã­dy odvodit potomka a v nÄ›m implementovat metody, kterÃ© jsou v *CCPU* abstraktnÃ­. RozhranÃ­ tÅ™Ã­dy je navrÅ¾eno takto:

* **Konstruktor CCPU(memStart, pageTableRoot)**. Konstruktor inicializuje ÄlenskÃ© promÄ›nnÃ© podle parametrÅ¯. Parametr *memStart* udÃ¡vÃ¡ "opravdovÃ½" ukazatel na poÄÃ¡tek bloku pamÄ›ti, kterÃ½ byl simulaci pÅ™edÃ¡n pÅ™i volÃ¡nÃ­ *MemMgr*. DruhÃ½m parametrem je simulovanÃ¡ virtuÃ¡lnÃ­ adresa, strÃ¡nky, kde je umÃ­stÄ›n adresÃ¡Å™ strÃ¡nek nejvyÅ¡Å¡Ã­ ÃºrovnÄ› (toto nastavenÃ­ strÃ¡nkovÃ¡nÃ­ bude pouÅ¾ito pro pÅ™epoÄet adres v tomto simulovanÃ©m CPU).
* **Destruktor** mÅ¯Å¾ete v odvozenÃ© tÅ™Ã­dÄ› implementovat, pokud budete potÅ™ebovat uvolÅˆovat alokovanÃ© prostÅ™edky.
* Metoda **GetMemLimit** zjistÃ­, kolik strÃ¡nek mÃ¡ alokovanÃ½ch proces, pro kterÃ½ je pouÅ¾Ã­vÃ¡na tato instance *CCPU*. Tato metoda je abstraktnÃ­, jejÃ­ implementace v odvozenÃ© tÅ™Ã­dÄ› je VÃ¡Å¡ Ãºkol.
* Metoda **SetMemLimit** nastavÃ­ pamÄ›Å¥ovÃ½ limit (v poÄtu strÃ¡nek) pro tento proces. Metoda mÅ¯Å¾e bÃ½t pouÅ¾ita jak pro zvÄ›tÅ¡enÃ­, tak pro zmenÅ¡enÃ­ pamÄ›Å¥ovÃ©ho prostoru simulovanÃ©ho procesu. NÃ¡vratovou hodnotou je *true* pro ÃºspÄ›ch, *false* pro neÃºspÄ›ch (napÅ™. nenÃ­ dostatek pamÄ›ti pro alokaci). Implementace je VÃ¡Å¡ Ãºkol.
* Metoda **NewProcess** vytvoÅ™Ã­ novÃ½ simulovanÃ½ proces (vlÃ¡kno). Parametrem volÃ¡nÃ­ je adresa funkce spouÅ¡tÄ›nÃ© v novÃ©m vlÃ¡knÄ›, jejÃ­ parametr a pÅ™Ã­znak *copyMem*. VÃ½znam prvnÃ­ch parametrÅ¯ je zÅ™ejmÃ½. TÅ™etÃ­ parametr udÃ¡vÃ¡, zda mÃ¡ bÃ½t novÄ› vzniklÃ©mu "procesu" vytvoÅ™en prÃ¡zdnÃ½ adresnÃ­ prostor (hodnota *false*, *GetMemLimit* v novÃ©m procesu bude vracet 0) nebo zda mÃ¡ zÃ­skat pamÄ›Å¥ovÃ½ obsah jako kopii pamÄ›Å¥ovÃ©ho prostoru stÃ¡vajÃ­cÃ­ho procesu (*true*). ÃšspÄ›ch je signalizovÃ¡n nÃ¡vratovou hodnotou *true*, neÃºspÄ›ch *false*. Metodu budete implementovat v odvozenÃ© tÅ™Ã­dÄ›.
* Metoda **ReadInt** pÅ™eÄte hodnotu typu *uint32_t* ze zadanÃ© simulovanÃ© virtuÃ¡lnÃ­ adresy. NÃ¡vratovou hodnotou je hodnota *true* pro ÃºspÄ›ch nebo hodnota *false* pro selhÃ¡nÃ­. SelhÃ¡nÃ­m je napÅ™. pokus o ÄtenÃ­ mimo hranice alokovanÃ©ho adresnÃ­ho prostrou (reÃ¡lnÃ½ OS by v takovÃ© situaci vyvolal signÃ¡l "Segmentation fault", simulace bude reagovat takto mÃ­rnÄ›). Metoda je kompletnÄ› implementovanÃ¡ v dodanÃ© tÅ™Ã­dÄ›, VaÅ¡e implementace ji nebude nijak mÄ›nit. Pro zjednoduÅ¡enÃ­ pÅ™edpoklÃ¡dÃ¡me pouze zarovnanÃ½ pÅ™Ã­stup (zadanÃ¡ virtuÃ¡lnÃ­ adresa je nÃ¡sobek 4, tedy celÃ© ÄtenÃ­ se odehraje v jednÃ© strÃ¡nce).
* Metoda **WriteInt** zapÃ­Å¡e hodnotu typu int na zadanou simulovanou virtuÃ¡lnÃ­ adresu. NÃ¡vratovÃ¡ hodnota je *true* pro ÃºspÄ›ch nebo *false* pro neÃºspÄ›ch. Metoda je opÄ›t hotovÃ¡ v dodanÃ© tÅ™Ã­dÄ›. OpÄ›t pÅ™edpoklÃ¡dÃ¡me pouze virtuÃ¡lnÃ­ adresy jako nÃ¡sobky 4, tedy opÄ›t celÃ½ zÃ¡pis probÄ›hne v jednÃ© strÃ¡nce.
* Metoda **virtual2physical** pÅ™epoÄÃ­tÃ¡vÃ¡ simulovanou adresu ("virtuÃ¡lnÃ­" adresa v procesu) na adresu "fyzickou". Metoda je implementovanÃ¡ v dodanÃ© tÅ™Ã­dÄ›. Implementace odpovÃ­dÃ¡ chovÃ¡nÃ­ procesoru i386 pro zÃ¡kladnÃ­ variantu strÃ¡nkovÃ¡nÃ­ (2 ÃºrovnÄ› adresÃ¡Å™Å¯ strÃ¡nek, 4KiB strÃ¡nka, 1024 odkazÅ¯ v adresÃ¡Å™i strÃ¡nek). VaÅ¡e implementace nebude tuto metodu nijak mÄ›nit. Budete ale muset odpovÃ­dajÃ­cÃ­m zpÅ¯sobem vyplnit adresÃ¡Å™e strÃ¡nek, aby je metoda sprÃ¡vnÄ› zpracovala. V reÃ¡lnÃ©m OS je tato funkce "ukryta" v HW procesoru.
* Metoda **pageFaultHandler** je vyvolÃ¡na, pokud pÅ™i pÅ™epoÄtu adres dojde k chybÄ› - vÃ½padku strÃ¡nky. MÅ¯Å¾e se jednat o skuteÄnou chybu (neoprÃ¡vnÄ›nÃ½ pÅ™Ã­stup) nebo o zÃ¡mÄ›r (odloÅ¾enÃ­ strÃ¡nky na disk, implementace strategie copy-on-write). Metoda je vyvolÃ¡na s parametry pÅ™epoÄÃ­tÃ¡vanÃ© virtuÃ¡lnÃ­ adresy a pÅ™Ã­znaku, zda se jednÃ¡ o ÄtenÃ­ nebo zÃ¡pis. NÃ¡vratovou hodnotou metody je true pokud se podaÅ™ilo odstranit pÅ™Ã­Äinu vÃ½padku strÃ¡nky (napÅ™. naÄtenÃ­ strÃ¡nky z disku) nebo false pro indikaci trvalÃ©ho neÃºspÄ›chu (pÅ™Ã­stup k pamÄ›ti mimo alokovanÃ½ rozsah). Pokud je vrÃ¡ceno true, je pÅ™epoÄet adres zopakovÃ¡n, pro navrÃ¡cenou hodnotu false je pÅ™epoÄet ukonÄen a programu je vrÃ¡cen neÃºspÄ›ch (*ReadInt*/*WriteInt* vrÃ¡tÃ­ *false*). ImplicitnÃ­ chovÃ¡nÃ­ vracÃ­ vÅ¾dy *false*, toto chovÃ¡nÃ­ postaÄuje pro zÃ¡kladnÃ­ implementaci. Pokud se ale rozhodnete implementovat strategii copy-on-write, budete muset tuto metodu v podtÅ™Ã­dÄ› zmÄ›nit. Pozor, pokud trvale vracÃ­te *true* a neodstranÃ­te pÅ™Ã­Äinu vÃ½padku, skonÄÃ­ program v nekoneÄnÃ© smyÄce. ReÃ¡lnÃ½ HW signalizuje vÃ½padek strÃ¡nky nÄ›jakÃ½m pÅ™eruÅ¡enÃ­m, obsluha pÅ™eruÅ¡enÃ­ odpovÃ­dÃ¡ tÃ©to metodÄ›. Pokud na reÃ¡lnÃ©m HW obsluha pÅ™eruÅ¡enÃ­ neodstranÃ­ pÅ™Ã­Äinu vÃ½padku a poÅ¾aduje opakovÃ¡nÃ­ pÅ™epoÄtu adres, mÅ¯Å¾e tÃ©Å¾ dojÃ­t k zacyklenÃ­ nebo k pÅ™eruÅ¡enÃ­ typu double-fault.
* Konstanta **OFFSET_BITS** udÃ¡vÃ¡ poÄet bitÅ¯ pouÅ¾itÃ½ch pro adresaci uvnitÅ™ strÃ¡nky (zde 12 bitÅ¯).
* Konstanta **PAGE_SIZE** udÃ¡vÃ¡ velikost strÃ¡nky v bajtech (4096 B).
* Konstanta **PAGE_DIR_ENTRIES** udÃ¡vÃ¡ poÄet zÃ¡znamÅ¯ v adresÃ¡Å™i strÃ¡nek (zde 1024).
* PoloÅ¾ka adresÃ¡Å™e strÃ¡nek mÃ¡ 4 bajty (32 bitÅ¯). JejÃ­ struktura je:
```
|31                             12|     |6|5|4|3|2|1|0|
+---------------------------------+-----+-+-+-+-+-+-+-+
| fyzickÃ¡ adresa strÃ¡nky/adresÃ¡Å™e |xxxxx|D|R|x|x|U|W|P|
+---------------------------------+-----+-+-+-+-+-+-+-+
```      
  * Konstanta **ADDR_MASK** obsahuje masku, kterÃ¡ pÅ™iloÅ¾enÃ¡ k poloÅ¾ce adresÃ¡Å™e strÃ¡nek zachovÃ¡ pouze adresu strÃ¡nky/adresu podÅ™Ã­zenÃ©ho adresÃ¡Å™e strÃ¡nek.
  * Konstanta **BIT_DIRTY** je nastavena CPU v pÅ™Ã­padÄ› zÃ¡pisu do strÃ¡nky (v obrÃ¡zku bit D).
  * Konstanta **BIT_REFERENCED** je nastavena CPU v pÅ™Ã­padÄ› ÄtenÃ­ ze strÃ¡nky (bit R v obrÃ¡zku).
  * Konstanta **BIT_USER** urÄuje, zda ke strÃ¡nce mÃ¡ pÅ™Ã­stup i uÅ¾ivatel (1) nebo pouze supervisor (0). Pro naÅ¡Ã­ simulaci bude potÅ™eba bit vÅ¾dy nastavit na 1 (bit U v obrÃ¡zku).
  * Konstanta **BIT_WRITE** urÄuje, zda lze do strÃ¡nky zapisovat (1) nebo pouze ÄÃ­st (0), bit W v obrÃ¡zku.
  * Konstanta **BIT_PRESENT** urÄuje, zda je strÃ¡nka pÅ™Ã­tomnÃ¡ (1) nebo odloÅ¾enÃ¡ na disk/nepÅ™Ã­stupnÃ¡ (0), bit P v obrÃ¡zku.
  * ZbÃ½vajÃ­cÃ­ bity nejsou v naÅ¡Ã­ simulaci pouÅ¾itÃ©. ReÃ¡lnÃ½ procesor jimi Å™Ã­dÃ­ cache (write-through/write-back/cache-disable), execute-disable a dalÅ¡Ã­ (i486+).

OdevzdÃ¡vejte zdrojovÃ½ kÃ³d s implementacÃ­ funkce MemMgr, podtÅ™Ã­dy *CCPU* a dalÅ¡Ã­ch podpÅ¯rnÃ½ch tÅ™Ã­d/metod. Za zÃ¡klad Å™eÅ¡enÃ­ pouÅ¾ijte zdrojovÃ½ soubor *solution.cpp* z pÅ™iloÅ¾enÃ© ukÃ¡zky. Pokud zachovÃ¡te bloky podmÃ­nÄ›nÃ©ho pÅ™ekladu, mÅ¯Å¾ete zdrojovÃ½ soubor *solution.cpp* rovnou odevzdÃ¡vat na *Progtest*.

VÅ¡imnÄ›te si, Å¾e pojmenovÃ¡nÃ­ VaÅ¡Ã­ podtÅ™Ã­dy *CCPU* nenÃ­ vÅ¯bec dÅ¯leÅ¾itÃ©. Instance tÃ©to tÅ™Ã­dy vyrÃ¡bÃ­ vÃ½hradnÄ› VaÅ¡e ÄÃ¡st implementace a testovacÃ­ prostÅ™edÃ­ pracuje pouze s polymorfnÃ­m rozhranÃ­m pÅ™edka.

NepokouÅ¡ejte se pro datovÃ© strÃ¡nky/adresÃ¡Å™e strÃ¡nek pouÅ¾Ã­vat pamÄ›Å¥ mimo pÅ™idÄ›lenÃ½ blok pamÄ›ti pÅ™edanÃ½ pÅ™i volÃ¡nÃ­ *MemMgr*. Implementace *CCPU* v testovacÃ­m prostÅ™edÃ­ kontroluje, zda jsou pouÅ¾itÃ© adresy strÃ¡nek/adresÃ¡Å™Å¯ strÃ¡nek z rozsahu spravovanÃ© pamÄ›ti. Pokud jsou mimo, Å™eÅ¡enÃ­ bude odmÃ­tnuto.

ZÃ¡kladnÃ­ verze programu musÃ­ umÄ›t spouÅ¡tÄ›t procesy bez kopÃ­rovÃ¡nÃ­ adresnÃ­ho prostoru (parametr *copyMem* bude v tÄ›chto testech vÅ¾dy false). TakovÃ© Å™eÅ¡enÃ­ neprojde nepovinnÃ½m a bonusovÃ½m testem, tedy bude hodnoceno mÃ©nÄ› body.

Å˜eÅ¡enÃ­, kterÃ© bude sprÃ¡vnÄ› (ale neefektivnÄ›) zpracovÃ¡vat parametr copyMem, projde i nepovinnÃ½m testem a dostane nominÃ¡lnÃ­ hodnocenÃ­ 100% bodÅ¯. Pro zvlÃ¡dnutÃ­ poslednÃ­ho (bonusovÃ©ho) testu je potÅ™eba sprÃ¡vnÄ› a hlavnÄ› efektivnÄ› kopÃ­rovat obsah adresnÃ­ho prostoru volajÃ­cÃ­ho do novÄ› vzniklÃ©ho procesu (je-li to poÅ¾adovÃ¡no). ProstÃ© kopÃ­rovÃ¡nÃ­ nestaÄÃ­, nebude mÃ­t k dispozici dost pamÄ›ti. SprÃ¡vnÃ© Å™eÅ¡enÃ­ bude muset pouÅ¾Ã­t techniku copy-on-write.

Pro testovÃ¡nÃ­ vyuÅ¾ijte pÅ™iloÅ¾enÃ½ archiv s nÄ›kolika pÅ™ipravenÃ½mi testy. Tyto testy (a nÄ›kterÃ© dalÅ¡Ã­ testy) jsou pouÅ¾itÃ© v testovacÃ­m prostÅ™edÃ­. DodanÃ© testy dÃ¡le ukazujÃ­ pouÅ¾itÃ­ poÅ¾adovanÃ½ch funkcÃ­/tÅ™Ã­d.

Ve zdrojovÃ½ch kÃ³dech pÅ™iloÅ¾enÃ©ho archivu je vidÄ›t seznam dostupnÃ½ch hlaviÄkovÃ½ch souborÅ¯. VÅ¡imnÄ›te si, Å¾e STL nenÃ­ dostupnÃ¡. ReÃ¡lnÃ½ OS takÃ© nemÃ¡ STL k dispozici (nenÃ­ new/delete), navÃ­c byste si museli implementovat vlastnÃ­ alokÃ¡tory.
